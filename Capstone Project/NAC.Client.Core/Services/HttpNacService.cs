using System.Net.Http.Json;
using NAC.Client.Core.Interfaces;
using NAC.Client.Core.Models; // Points to your client-side models

namespace NAC.Client.Core.Services
{
    public class HttpNacService : INacService
    {
        private readonly HttpClient _httpClient;
        private const string ServerUrl = "https://192.168.1.7:5000"; // ⚠️ CHANGE THIS if Server is on another PC

        public bool IsConnected { get; private set; }
        public DeviceInfo? CurrentDeviceInfo { get; private set; }

        private Timer? _heartbeatTimer;

        // Fields to store session data
        private string? _currentSessionToken;
        private string? _currentUsername;
        private string? _currentDeviceId;

        public HttpNacService()
        {
            // 1. SETUP HTTP CLIENT
            // This handler allows "localhost" certificates (needed for testing)
            var handler = new HttpClientHandler
            {
                ServerCertificateCustomValidationCallback = (sender, cert, chain, sslPolicyErrors) => true
            };
            _httpClient = new HttpClient(handler) { BaseAddress = new Uri(ServerUrl) };
        }

        public async Task<LoginResponse> LoginAsync(LoginRequest request, CancellationToken ct = default)
        {
            try
            {
                // 2. SEND LOGIN TO SERVER
                var response = await _httpClient.PostAsJsonAsync("/api/auth/login", request, ct);

                if (response.IsSuccessStatusCode)
                {
                    // 3. READ THE SERVER RESPONSE
                    // We must read the body to get the 'SessionToken' generated by the server.
                    var result = await response.Content.ReadFromJsonAsync<LoginResponse>(cancellationToken: ct);

                    if (result != null && result.Success)
                    {
                        // Success! Save the token for the heartbeat.
                        _currentSessionToken = result.SessionToken;
                        _currentUsername = request.Username;
                        _currentDeviceId = request.DeviceId;
                        IsConnected = true;

                        return result; // Return the full response from server
                    }
                    else
                    {
                        // Server returned 200 OK, but said Success=false (e.g. bad password logic handled manually)
                        return result ?? new LoginResponse
                        {
                            Success = false,
                            Message = "Unknown login error."
                        };
                    }
                }
                else
                {
                    // Server said "Unauthorized" (401) or "Error" (500)
                    return new LoginResponse
                    {
                        Success = false,
                        Message = $"Server Error: {response.StatusCode}"
                    };
                }
            }
            catch (Exception ex)
            {
                // Server is probably offline
                return new LoginResponse
                {
                    Success = false,
                    Message = $"Could not connect to server: {ex.Message}"
                };
            }
        }

        public async Task<Phase2ValidationResponse> ValidatePhase2Async(Phase2ValidationRequest request, CancellationToken ct = default)
        {
            // Since our Server's "Login" endpoint already opened the firewall,
            // Phase 2 here is just a local confirmation or we could call the server again if needed.

            CurrentDeviceInfo = request.DeviceInfo;
            IsConnected = true;

            return await Task.FromResult(new Phase2ValidationResponse
            {
                Passed = true, // Matches your Model property 'Passed'
                Success = true,
                Message = "Phase 2 Complete. Firewall is Open."
            });
        }

        public Task StartHeartbeatAsync(CancellationToken cancellationToken)
        {
            // Start a timer that ticks every 30 seconds
            _heartbeatTimer = new Timer(async _ => await SendHeartbeatAsync(),
                                        null,
                                        TimeSpan.Zero,
                                        TimeSpan.FromSeconds(30));
            return Task.CompletedTask;
        }

        private async Task SendHeartbeatAsync()
        {
            // We need a session token to send a heartbeat.
            if (!IsConnected || string.IsNullOrEmpty(_currentSessionToken)) return;

            try
            {
                var heartbeat = new HeartbeatRequest
                {
                    SessionToken = _currentSessionToken,
                    DeviceInfo = CurrentDeviceInfo ?? new DeviceInfo
                    {
                        DeviceName = _currentDeviceId ?? "Unknown",
                        IpAddress = "0.0.0.0",
                        ConnectedAt = DateTime.Now
                    }
                };

                // POST /api/heartbeat
                await _httpClient.PostAsJsonAsync("/api/heartbeat", heartbeat);
            }
            catch
            {
                // If heartbeat fails, mark as disconnected
                IsConnected = false;
            }
        }

        public async Task LogoutAsync(CancellationToken cancellationToken = default)
        {
            // Stop the heartbeat
            _heartbeatTimer?.Dispose();

            // Tell server to close the firewall
            try
            {
                await _httpClient.PostAsync("/api/auth/logout", null, cancellationToken);
            }
            catch { /* Ignore logout errors */ }

            IsConnected = false;
            _currentSessionToken = null;
        }

        public Task StopHeartbeatAsync()
        {
            _heartbeatTimer?.Dispose();
            return Task.CompletedTask;
        }
    }
}